Session 3 - Read, Generate, Modify configuration
--------------------------------------------------------

***** Understand attributes and output values in terraform
Terraform has capability to output the attribute of a resource with the output values.
Example:
ec2_public_ip = 35.161.21.197
bucket_identifier = terraform-test-kplabs.s3.amazonaws.com

An Output attributes can not only be used for the user reference but it can also act as a input to other resources being created via terraform
example:
After EIP gets created, its IP address should automatically get whitelisted in the security group


vi s3.tf
provider "aws" {
region = "us-west-2"
access_key = "sadfsdfsdf"
secret_key = "sdfsdfsdfd"
}

resources "aws_eip" "lb" {
vpc = true
}

output "eip" {
  value = aws_eip.lb.public_ip
  }

resource "aws_s3_bucket" "my_s3" {
  bucket = "kplabs-attribute-demo-001"
  }

output "mys3bucket" {
value = aws_s3_bucket.mys3.bucket_domain_name
}

public_ip and bucket_domain_name are the attribute associated with the resource


# terraform plan

# terraform apply

attributes reference

if you are not using attributes refereence, the output will show all the attributes of the resource.


***** Referencing cross-account resource
vi reference.tf
provider "aws" {
  region = "us-west-2"
  access_key = "sfdsdfdsfsdf"
  secret_key = "sadfsdfsdf"
  }

resource "aws_instance" "myec2" {
  ami = "ami-fdfsdfsdfsdfsdf"
  instance_ty[e = t2.micro
  }

resource "aws_eip" "lb" {
  vpc = true
  }

resource "aws_eip_association" "eip_assoc" {
  instance_id = aws_instance.myec2.id
  allocation_id = "${aws_eip.lb.id
}

# terraform plan
# terraform apply


***** Terraform variables
Static = work
- Repeated static values can create more work in future

Variables are good
We can have a central source from which we can import the values from


***** Approaches for variable assignment
If not explicit value has been defined, it uses the default value in the variable file

Variables in Terraform can be assigned values in multiple ways
Some of these include
- Environment variables
- Command line flags
- From a file
- Variable defaults

# terraform plan

# terraform plan -var="instancetype=t2.small"

If there are no default values, we can see value assigned with var.instancetype (it will ask for selection)

File based perspective

vi terraform.tfvars

Generally, it is always good to have terraform.tfvars

# terraform plan -var-file="custom.tfvars"

export TF_VAR_instancetype="t2.nano"
export $TF_VAR_instancetype


***** Data Types for variables

The type arguement in a variable block allows you to restrict
the type of value that will be accepted as the value for a 
variable.

variable "image_id" {
    type = string
}

If no type constraint is set then a value of any type is accepted.

Demo
----
provider "aws" {
  region = "ap-southeast-2"
  access_key = "asdsdsad"
  secret_key = "sdfsdfsdfs"
}

resource "aws_iam_user" "lb" {
  name = var.usernumber
  path = "/system"
}

variables.tf
variable "usernumber" {
     type = number
}


Type keywords
1. String  
2. List
3. Map
4. number

vi elb.tf
provider "aws" {
  region = "ap-southeast-2"
  access_key = "asdsdsad"
  secret_key = "sdfsdfsdfs"
}


***** Fetching data from maps and list from variable

example
resource "aws_instance" "myec2" {
  ami = "ami-sdfsdfs"
  instance_type = var.types["us-west-2"]
}

variable "list" {
  type = list
  default = ["m5.large",m5.xlarge","t2.medium"]
}

variable "types" {
  type = map
  default = {
    us-east-1 = "t2.micro"
    us-west-2 = "t2.nano"
    ap-south-1 = "t2.small"
  }
  }
}

resource "aws_instance" "myec2" {
  ami = "ami-sdfsdfs"
  instance_type = var.list["0"]
}

variable "list" {
  type = list
  default = ["m5.large",m5.xlarge","t2.medium"]
}

variable "types" {
  type = map
  default = {
    us-east-1 = "t2.micro"
    us-west-2 = "t2.nano"
    ap-south-1 = "t2.small"
  }
  }
}


***** Count parameters
The Count parameter on resources can simplify configurations
and let you scale resources by simply incrementing a number

Lets assume, you need to create two Ec2 instances. One of the
common approach is to define two seperate resorce blocks for 
aws_instance.

resource "aws_instance" "instance-1" {
  ami = "amiasdsdssad"
  instance_type = "t2.micro"
  count = 3
}

count.index - allows us to fetch the index of each iteration
in the loop

resource "aws_iam_user" "lb" {
  name = "loadbalancer.${count.index}"
  count = 5
  path = "/system/"
}

- Understanding challenge with default count index
Having a username like loadbalancer0, loadbalancer1 might
not always be suitable.

Better names like dev-loadbalancer, stage-loadbalancer,
prod-loadbalancer is better.

count.index can help in such scenario

variable "elb_names" {
  type = list
  default = ["dev-loadbalancer", "stage-loadbalancer", "prod-loadbalancer"]
}

example:
provider "aws" {
  region = "ap-southeast-2"
  access_key = "asdsdsad"
  secret_key = "sdfsdfsdfs"
}

variable "elb_names" {
  type = list
  default = ["dev-loadbalancer", "stage-loadbalancer", "prod-loadbalancer"]
}

resource "aws_iam_user" "lb" {
  name = var.elb_names[count.index]
  count = 3
  path = "/system/"
}


***** Conditional expressions
A conditional expression uses the value of a bool 
expression to select one of two values

Syntax of conditional expression

condition ? true_val : false_val

If condition is true then the result is true_val. If
condition is false then the result is false_val.

Lets assume that there are two resource blocks as part of
terraform configuration.

Depending on the variable value, one of the resource blocks
will run.

example
provider "aws" {
  region = "ap-southeast-2"
  access_key = "asdsdsad"
  secret_key = "sdfsdfsdfs"
}

resource "aws_instance" "dev" {
  ami = "dflkjsdfljsdf"
  instance_type = t2.micro
  count = var.istest == true ? 1 : 0
}

resource "aws_instance" "prod" {
  ami = "dflkjsdfljsdf"
  instance_type = "t2.large"
  count = var.istest == false ? 1 : 0
}


vi terraform.tfvars
istest = true


***** Overview of local values
A local value assigns a name to an expression, allowing
it to be used multiple times within a module without repeating
it.

example:

provider "aws" {
  region = "ap-southeast-2"
  access_key = "asdsdsad"
  secret_key = "sdfsdfsdfs"
}

locals {
  common_tags = {
    owner = "DevOps Team"
    service = "backend"
  }
}

resource "aws_instance" "app-dev" {
  ami = ami-sdlfkjsdlfkjskdlf
  instance_type = "t2.micro"
  tags = local.common_tags
}

resource "aws_ebs_volume" "db_ebs" {
  availability_zone = "us-west-2a"
  instance_type = "t2.small"
  tags = local.common_tags
}

Local values support for expression

Local values can be used for multiple different use-cases
like having a conditional expression.

locals {
  name_prefix = "${var.name != "" ? var.name : var:default}"
}


- Important pointers for local values
Local values can be helpful to avoid repeating the same
values or expressions multiple times in a configuration

If overused they can also make a configuration hard to read
by future maintainers by hiding the actual value used.

Use local values only in moderation, in situations where
a single value or result is used in many places and that
value is likely to be changed in future.


***** Terraform functions
The terraform language includes a number of built-in
functions that you can use to transform and combine values

The general syntax for fucntion calls is a function name
followed by comma-seperated arguements in parentheses

function (arguement1,arguement2)

  Example
  > max(5, 12, 9)
    12

The terraform language does not support user-defined functions,
and so only the functions built in to the language are availbale
for use
- Numeric
- String
- Collection
- Encoding
- Filesystem
- Date and time
- Hash and Crypto
- IP Network
- Type Conversion

terraform console - test functions


***** Data sources
Data sources allow data to be fetched or computed for use
elsewhere in Terraform configuration

- Define under the data block
- Reads from a specific data source (aws_ami) and export 
results under "app_ami"

data "aws_ami" "app_ami" {
  most_recent = true
  owners = ["amazon"]

  filter {
    name = "name"
    values = ["amzn2-ami-hvm*"]
  }
}

resource "aws_instance" "instance-1" {
  ami = data.aws_ami.app_ami.id
  instance_type = "t2.micro"
}


***** Debugging in terraform
Terraform has detailed logs which can be enabled by setting
the TF_LOG environment variable to any value

You can set TF_LOG to one of the log levels TRACE, DEBUG, INFO
WARN or ERROR to change the verbosity of the logs

# export TF_LOG=TRACE

# export TF_LOG_PATH=/tmp/terraform-crash.log

TRACE is the most verbose and it is the default if TF_LOG is
set to something other than a log level name

To persist logged output you can set TF_LOG_PATH in order to
force the log to always be appended to a specific file when
logging is enabled


***** Terraform format
Anyone who is into programming knows the inportance of formatting
the code for readability.

The terraform "fmt" command is used to rewrite terraform 
configuration files to take care of overall formatting

# terraform fmt



***** Validating teraform configuration
- Terraform validate
Terraform variable primarily checks whether a configuration
is syntactically valid.

It can chedk various aspects including unsupported arguements,
undeclared variables and others


***** Load order and semantics
Terraform generally loads all the configuration files within
the directory specified in alphabetical order

The files loaded must end in either .tf or .tf.json to specify
the format that is in use


***** Dynamic block
In many of the use-cases, there are repeatable nested blocks
that needs to be defined

This can lead to a long code and it can be difficult to manage
in longer time

Dynamic blockk allows us to dynamically construct repeatable
nested blocks which is supported inside resource, data, provider,
and provisioner blocks.

example:
dynamic "ingress" {
  for_each = var.ingress_ports
  content {
    from_port = ingress.value
    to_port = ingress.value
    protocol = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

Iterator arguement sets the name of a temporary variable that
represents the current element of the complex value

If omitted, the name of the variable defaults to the label
of the dynamic block ("ingress" in the example)

dynamic "ingress" {
  for_each = var.ingress_ports
  content {
    from_port = ingress.value
    to_port = ingress.value
    protocol = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

dynamic "ingress" {
  for_each = var.ingress_ports
  iterator = port
  content {
    from_port = port.value
    to_port = port.value
    protocol = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}


***** Tainting resources
- Terraform taint
You have created a new resource via terraform
Users have made a lot of manual changes (both infrastructure
and inside the server)
Two ways to deal with this: Import the changes to terraform
or delete and recreate the resource

The terraform taint command manually marks a terraform-managed
resource as tainted, forcing it to be destroyed and recreated
on the next apply

# terraform taint aws_instance.myec2

# terraform plan

Important Pointers:

- The terraform taint command will not modify infrastructure, 
but does modify the state file in order to mark a resource as
tainted

- Once a resource is marked as tainted, the next plan will show
that the resource will be destroyed and recreated and the 
next apply will implement this change

-note that tainting a resource for recreation may affect resource
that depend on the newly tainted resource.


***** Splat expression
splat expression allows us to get a list of all the attributes

example:
resource "aws_iam_user" "lb" {
  name = "iamuser.${count.index}"
  count = 3
  path = "/system"
}

output "arns" {
  value = aws_iam_user.lb[*].arn
}


***** Terraform graph
Terraform graph command is used to generate a visual
representation of either a configuration or execution plan

The output of terraform graph is in the DOT format, which
can easily be converted to an image.

# terraform graph > graph.dot
# cat graph.dot |dot -Tsvg > graph.svg
(copy the content)
# vi graph.svg
(paste the content)
(open the file with chrome)


***** Saving terrraform plan to a file
The generated terraform plan can be saved to a specific path

This plan can then be used with terraform apply to be certain
that only the changes shown in this plan are applied

Example:
# terraform plan -out=path

# terraform pan -out=demopath

# terraform apply demopath



***** Terraform output
The terraform output command is used to extract the value
of an output variable from the state file.

# terraform output iam_arn
# terraform output iam_names


***** Terraform settings
The special terraform configuration block type is used to
configure some behaviors of terraform itself, such as requiring
a minimum terraform version to apply your configuration.

Terraform settings are gathered together into terraform blocks

Setting 1 - The required_version setting accepts a version
constraint string, which specifies which versions of terraform
can be used with your configuration.

If the running version of terraform doesn't match the constraints
specified, terraform will produce an error and exit without taking
further actions.

example:
terraform {
  required_version = "> 0.12.0"
}

The required_providers block specifies all of the providers
required by the current module, mapping each local provider 
name to a source address and a version constraint.

Example:
terraform {
  required_providers {
    my cloud = {
      source = "mycorp/mycloud"
      version = "~> 1.0"
    }
  }
}


***** Dealing with larger infrastructure
When you have a larger infrastructure, you will face issues
related to API limits for a provider.

Switch to smaller configuration where each can be applied 
independently

- Specify the target
The -target=resource flag can be used to target a specific 
resource

generally used as a means to operate on isolated portions
of very large configurations

# terraform plan -refresh=false

# terraform plan -refresh=false -target=aws_security_group.allow_ssh_conn

 